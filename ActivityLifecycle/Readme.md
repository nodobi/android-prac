
# 소개
안드로이드 4대 컴포넌트 중 한 종류인 액티비티의 생명주기와 관련된 내용을 정리하고 실제 동작을 통해 확인하기 위해서 만들어진 프로젝트입니다.

# 내용
## 액티비티 생명주기란?
사용자는 앱을 나가고, 다시 들어오는 등의 여러 동작들을 수행하게 된다. 앱은 이러한 사용자의 동작에 따라 어떠한 작업을 멈추기도 하고 다시 재개하기도 하는 작업을 수행해야 하는 경우가 많다.

예를 들어 뮤직 플레이어가 음악에 따라 화면에서 여러 애니메이션을 보여주고 있다면, 사용자가 앱을 나갔을 때는 이러한 애니메이션을 계속 움직여줄 필요가 없다.

이렇게 사용자 동작에 맞추어 작업을 하기 위해 `Activity` 클래스는 상태가 변경되거나 시스템에 의해 생성, 종료되는 경우 이를 개발자가 대응할 수 있도록 생명주기 함수로 여러 콜백을 제공한다.

### 왜 필요할까?
모바일 환경에서는 메모리와 같은 하드웨어 성능을 잘 관리하는게 중요하다.

그러기 위해서 안드로이드 운영체제는 현재 보여지고 있는 액티비티가 동작중인 프로세스를 종료시킬 수도 있다.

따라서 개발자는 해당 상황에 맞추어 어떠한 상태를 저장해야 할 수도 있고 어떠한 작업을 수행해야 할 수도 있다.

이를 콜백 함수를 통해 진행하는 것이다.

또한 아래 문제를 해결하는 데 도움을 줄 수 있다.
- 사용자가 앱을 사용하는 도중 다른 앱으로 전환 후 비정상 종료되는 경우
- 사용자가 앱을 활발하게 사용하지 않는 경우 리소스가 소비되는 문제
- 사용자가 앱에서 나갔다가 다시 들어오는 경우 진행 상황이 저장되지 않는 경우
- 화면이 가로 세로로 회전되는 경우

## 각 수명주기 콜백
### onCreate()
시스템이 액티비티를 생성할 때 실행되는 메소드, 필수적으로 구현해야 하며(어떤 레이아웃을 사용할지 정해야 하기에) 액티비티가 생성되면 `Created` 상태가 된다.
액티비티의 전체 수명주기 동안 **한 번만** 발생한다

메소드의 매개변수로 액티비티의 이전에 저장된 상태를 가지고 있는 `Bundle` 객체를 받는다.이전에 액티비티가 없었던 경우 null 값을 가지게 된다.

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_CREATE` 이벤트를 수신한다.

이 메소드가 실행된 이후로 액티비티는 `Started` 상태가 되고 다음의 `onStart()` 메소드를 호출한다. 즉 `Created` 상태가 유지되지는 않는다.

### onStart()
액티비티가 `Started` 상태에 진입하는 경우 호출되는 콜백 메소드

메소드가 실행된 이후 `onCreate()` 메소드와 마찬가지로 `Started` 상태가 유지되는 것이 아닌 `Resumed` 상태로 전환되고 `onResume()` 메소드를 호출한다.

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_START` 이벤트를 수신한다.

이 메소드를 통해 액티비티가 사용자와 상호작용 할 수 있도록 준비된다.

### onResume()
액티비티가 `Resumed` 상태에 진입하는 경우 호출되는 콜백 메소드

이 상태에 진입하면 사용자와 앱이 상호작용한다. 이 때 카메라의 미리보기를 시작하는 등 포그라운드에서 사용자에게 보이는 기능들을 실행하게 된다.

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_RESUME` 이벤트를 수신한다.

사용자가 화면을 벗어나거나 화면이 꺼지는 등 앱에서 **포커스를 잃을 때 까지** 이 상태를 유지한다. 그렇지 않을 경우 액티비티는 `Paused` 상태가 되고 `onPause()` 메소드를 호출한다. 따라서 이 메소드에서는 `onPause()` 메소드에서 해제되는 요소들을 초기화하는 작업도 포함된다.

단, 사용자가 멀티 윈도우를 사용하는 경우 `Paused` 상태에서도 화면이 보여지고 있을 수도 있다.

### onPause()
시스템이 사용자가 액티비티를 떠났다는 첫 번째로 알리는 콜백 메소드이다. 단, 이 말이 항상 액티비티가 소멸한다는 것은 아니다. 

액티비티가 `Paused` 상태로 전환되는 경우
- 앱 실행을 중단하는 이벤트가 발생하는 경우 (일반적이다)
- 멀티 윈도우 모드에서 두 개의 앱을 사용하는 경우 (멀티 윈도우 모드에서는 한 개의 앱만 포커스를 가짐)
- 다이얼로그와 같은 semi-transparent activity 를 여는 경우

이 메소드에서는 카메라 미리보기와 같이 액티비티가 포그라운드에 있지 않을 때 실행할 필요가 없는 기능들을 정지하는 작업이 들어간다.

**단 이때 주의할 점이 있다**

`onPuase()` 의 실핸 시간은 매우 짧기 때문에 작업을 수행하는 도중에 종료될 수도 있다. 따라서 아래 몇 가지 작업들은 `onStop()` 콜백에서 수행하는 것이 적절 할 수도 있다.
- 애플리케이션 혹은 사용자 데이터 저장
- 네트워크 호출
- 데이터베이스 트랜젝션

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_PAUSE` 이벤트를 수신한다.

메소드의 동작이 마치고 나서 액티비티는 `Paused` 상태를 유지한다. 그러다 액티비티가 완전히 보이지 않게 된다면 시스템은 액티비티의 상태를 `Stopped`로 변경하고 `onStop()` 을 호출한다.

### onStop()
활동이 사용자에게 더 이상 표시되지 않을 때 발생하는 콜백 메소드이다.

예를 들어 새로 시작된 다른 액티비티가 전체 화면을 차지할 때 기존 액티비티에서 발생한다. 또한 시스템은 액티비티의 실행이 완료되고 종료되려고 할 때 `onStop()` 을 호출한다.

따라서 여기에선 에니메이션 일시중지와 같이 화면이 보이지 않을 때 실행할 필요가 없는 기능을 모두 정지할 수 있다. 또 종료 가정에서 필요한 데이터베이스에 데이터를 저장하는 등 CPU를 많이 사용하는 작업을 여기서 실행하기에 좋다.

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_STOP` 이벤트를 수신한다.

액티비티가 `Stopped` 상태가 되더라도 액티비티 객체는 메모리에서 삭제되지 않는다. 즉 객체제 저장되어 있는 모든 상태들이 삭제되지 않는다. 다만 안드로이드 시스템이 현재 액티비티가 포함되어 있는 프로세스를 강제로 종료할 수도 있다.

그렇게 되는 경우 어떠한 현상이 발생하냐면 액티비티는 View 객체의 여러 상태를 **Bundle** 에 저장하고 나중에 불러옴으로써 View 객체들의 상태를 유지한다.

현재 상태에서 다시 액티비티가 시작된다면, 시스템은 `onRestart()` 메소드를 호출하고 액티비티가 실행을 종료된다면 시스템은 `onDestroy()` 메소드를 호출한다.

### onDestroy()
액티비티가 소멸되기 전에 호출되는 콜백 메소드이다.

이 콜백이 호출되는 경우는 다음과 같다
- 사용자가 액티비티를 완전히 닫아 액티비티가 종료되는 경우
- 액티비티에서 `finish()` 메소드가 호출되는 경우
- 멀티 윈도우 혹은 화면 회전과 같은 행동으로 인해 액티비티가 **일시적으로 파괴**되고 구성이 변경되는 경우

이로 인해 액티비티가 종료되는 경우 이 메소드에서 액티비티가 소멸되기 전에 필요한 모든 작업들을 할 수 있다.

이 메소드에 종료와 관련된 여러 로직을 수행하는 대신 `ViewModel` 객체를 사용해서 액티비티와 관련된 뷰 데이터를 유지할 수 있다. 이렇게 `ViewModel` 객체를 사용하는 경우 **액티비티 인스턴스가 생성될 떄 데이터를 다시 제공**받을 수 있다.

만약 JetPack 라이브러리의 Lifecycle 과 같은 lifecycle-aware Component 가 존재하는 경우 `ON_DESTORY` 이벤트를 수신한다.

## 시스템이 프로세스를 강제로 종료하는 경우
시스템은 메모리를 확보해야 할 때 프로세스를 종료하게 된다. 시스템이 프로세스를 종료할 가능성은 프로세스의 상태에 따라 달라지고 프로세스 상태는 해당 프로세스에서 실행되는 액티비티의 상태에 따라 달라진다.

|가능성|프로세스 상태|마지막 액티비티 상태|
|:---:|:---:|:---:|
|가장 낮음|포그라운드(포커스가 있거나 포커스를 가져올 예정)|`Resumed`|
|낮음|포커스 없이 보여지는 경우|`Started`/`Paused`|
|약간 높음|백그라운드(보여지지 않은 상태)|`Stopped`|
|가장 높음|비어있는 경우|`Destroyed`|

# 실제 동작
MainActivity 에서 SecondActivity 로 `startActivity()` 를 통해 이동하는 경우 생명주기는 다음과 같이 동작한다.

```
MainActivity| onCreate()
MainActivity| onStart()
MainActivity| onResume()
MainActivity| Change Activity       // startActivity() 호출
MainActivity| onPause()
SecondActivity| onCreate()
SecondActivity| onStart()
SecondActivity| onResume()
MainActivity| onStop()
```

왜 이러한 흐름으로 동작이 되는지를 생각해보면, 기억하기 더 쉬울 것 같다. 액티비티가 변경될 떄 사용자가 느끼기에 어색하지 않으려면, 새로운 화면이 준비될 떄 까지 다른 화면을 끄지 않아야 한다.

즉 변경될 액티비티의 상태가 `Resumed` 상태가 되기 전 까지는 기존 액티비티의 상태가 `Stopped`가 되지 않아야 한다는 의미로 기억하면 될 것이라 생각한다.

어떠한 콜백에서 초기화 작업을 한다면, 그에 상응하는 라이프 사이클 콜백에서 해당 리소스를 해제해야 한다. 예를 들어 `onStart()` 콜백에서 초기화 작업을 진행했다면, `onStop()` 콜백에서 하고 `onResume()` 콜백에서 초기화 작업을 진행헀다면, `onPause()` 콜백에서 해제하는 것이다.


# 추가하면 좋을 것들
안드로이드 OS 에서 프로세스를 강제로 종료하는 경우가 어떤게 있는지
- 강제로 종료되는 경우와 사용자가 정상적으로 종료하는 경우도 구분할 수 있을까?

이떄까지 `onStart()` 메소드를 오버라이딩해서 사용해 본 적은 없는 것 같은데, 사용 예시 찾아보거나 이유 알아보기

# 참고 자료
[안드로이드 공식문서](https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ko)